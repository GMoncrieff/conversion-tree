<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Final Recommendation - Land Cover Change Decision Tool</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <div class="progress-bar">
        <div class="progress-step completed">Preamble</div>
        <div class="progress-step completed">Pathway</div>
        <div class="progress-step completed">Demand</div>
        <div class="progress-step completed">Vulnerability</div>
        <div class="progress-step active">Recommendation</div>
    </div>

    <main class="container">
        <h1>Final Recommendation</h1>
        
        <div class="recommendation-card">
            <div id="recommendation-explanation" class="recommendation-explanation"></div>
            <h2>Recommended Software</h2>
            <div id="software-list" class="software-list"></div>
        </div>

        <div class="summary-section collapsible">
            <button class="collapsible-header" id="summary-toggle">
                <h2>Your Assessment Summary</h2>
                <span class="toggle-icon">▼</span>
            </button>
            <div class="collapsible-content" id="summary-content">
                <div class="tree-summary">
                    <div class="tree-column" id="pathway-column">
                        <h3>Pathway Assessment</h3>
                        <div id="pathway-tree-viz" class="tree-visualization"></div>
                    </div>
                    <div class="tree-column" id="demand-column">
                        <h3>Demand Assessment</h3>
                        <div id="demand-tree-viz" class="tree-visualization"></div>
                    </div>
                    <div class="tree-column" id="vulnerability-column">
                        <h3>Vulnerability Assessment</h3>
                        <div id="vulnerability-tree-viz" class="tree-visualization"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="navigation">
            <button class="btn btn-secondary" onclick="window.location.href='index.html'">Start Over</button>
        </div>
    </main>

    <script src="js/app.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            document.body.classList.add('loaded');
            
            // Get selections from sessionStorage
            const pathwayResult = sessionStorage.getItem('pathwayResult');
            const demandResult = sessionStorage.getItem('demandResult');
            const vulnerabilityResult = sessionStorage.getItem('vulnerabilityResult');
            const pathwayPath = JSON.parse(sessionStorage.getItem('pathwayPath') || '[]');
            const demandPath = JSON.parse(sessionStorage.getItem('demandPath') || '[]');
            const vulnerabilityPath = JSON.parse(sessionStorage.getItem('vulnerabilityPath') || '[]');

            console.log('=== SESSION STORAGE DEBUG ===');
            console.log('Pathway Result:', pathwayResult, '| Type:', typeof pathwayResult);
            console.log('Demand Result:', demandResult, '| Type:', typeof demandResult);
            console.log('Vulnerability Result:', vulnerabilityResult, '| Type:', typeof vulnerabilityResult);
            console.log('Pathway Path:', pathwayPath);
            console.log('=============================');

            // Load recommendation rules and explanations (with cache busting)
            const cacheBuster = Date.now();
            Promise.all([
                fetch(`data/recommendations.json?v=${cacheBuster}`).then(r => r.json()),
                fetch(`data/software-explanations.json?v=${cacheBuster}`).then(r => r.json())
            ]).then(([recommendationData, explanationsData]) => {
                console.log('Recommendation Data:', recommendationData);
                console.log('Explanations Data:', explanationsData);
                
                const recommendations = findRecommendation(recommendationData, pathwayResult, vulnerabilityResult, demandResult);
                console.log('Found Recommendations:', recommendations);
                
                // Display explanation if available
                if (recommendations.explanation) {
                    const explanationEl = document.getElementById('recommendation-explanation');
                    explanationEl.innerHTML = `<p>${recommendations.explanation}</p>`;
                }
                
                displayRecommendations(recommendations, explanationsData);
            }).catch(error => {
                console.error('Error loading recommendations:', error);
            });
            
            // Load and visualize trees based on what was completed
            if (pathwayResult) {
                fetch('data/pathway.json').then(r => r.json()).then(pathwayTree => {
                    visualizeTree('pathway-tree-viz', pathwayTree, pathwayPath);
                }).catch(error => {
                    console.error('Error loading pathway tree:', error);
                });
            } else {
                document.getElementById('pathway-column').style.display = 'none';
            }
            
            if (demandResult) {
                fetch('data/demand.json').then(r => r.json()).then(demandTree => {
                    visualizeTree('demand-tree-viz', demandTree, demandPath);
                }).catch(error => {
                    console.error('Error loading demand tree:', error);
                });
            } else {
                document.getElementById('demand-column').style.display = 'none';
            }
            
            if (vulnerabilityResult) {
                fetch('data/vulnerability.json').then(r => r.json()).then(vulnerabilityTree => {
                    visualizeTree('vulnerability-tree-viz', vulnerabilityTree, vulnerabilityPath);
                }).catch(error => {
                    console.error('Error loading vulnerability tree:', error);
                });
            } else {
                document.getElementById('vulnerability-column').style.display = 'none';
            }
            
            // Collapsible summary functionality
            document.getElementById('summary-toggle').addEventListener('click', () => {
                const content = document.getElementById('summary-content');
                const icon = document.querySelector('.toggle-icon');
                
                if (content.style.display === 'none' || content.style.display === '') {
                    content.style.display = 'block';
                    icon.textContent = '▲';
                } else {
                    content.style.display = 'none';
                    icon.textContent = '▼';
                }
            });
        });

        function findRecommendation(data, pResult, vResult, dResult) {
            console.log('Finding recommendation for:', { pResult, vResult, dResult });
            
            for (const rule of data.rules) {
                // Count how many conditions the rule specifies
                const ruleConditions = Object.keys(rule.if);
                let matchCount = 0;
                let requiredMatches = ruleConditions.length;
                
                // Check each condition
                if (rule.if.pathway) {
                    if (pResult && rule.if.pathway.includes(pResult)) {
                        matchCount++;
                    }
                }
                
                if (rule.if.vulnerability) {
                    if (vResult && rule.if.vulnerability.includes(vResult)) {
                        matchCount++;
                    }
                }
                
                if (rule.if.demand) {
                    if (dResult && rule.if.demand.includes(dResult)) {
                        matchCount++;
                    }
                }
                
                console.log('Rule:', rule.if, 'Required:', requiredMatches, 'Matched:', matchCount);
                
                // Rule matches if all its specified conditions are met
                if (matchCount === requiredMatches) {
                    console.log('Matched rule!', rule);
                    return {
                        simple: rule.recommend_simple || [],
                        intermediate: rule.recommend_intermediate || [],
                        advanced: rule.recommend_advanced || [],
                        explanation: rule.explanation || ''
                    };
                }
            }
            console.log('No matching rule found');
            return { simple: [], intermediate: [], advanced: [], explanation: '' };
        }

        function displayRecommendations(recommendations, explanations) {
            const listEl = document.getElementById('software-list');
            
            // Display simple recommendations
            if (recommendations.simple && recommendations.simple.length > 0) {
                const simpleHeader = document.createElement('div');
                simpleHeader.className = 'difficulty-header difficulty-simple';
                simpleHeader.textContent = 'Simple';
                listEl.appendChild(simpleHeader);
                
                recommendations.simple.forEach(software => {
                    createSoftwareItem(software, 'simple', explanations, listEl);
                });
            }
            
            // Display intermediate recommendations
            if (recommendations.intermediate && recommendations.intermediate.length > 0) {
                const intermediateHeader = document.createElement('div');
                intermediateHeader.className = 'difficulty-header difficulty-intermediate';
                intermediateHeader.textContent = 'Intermediate';
                listEl.appendChild(intermediateHeader);
                
                recommendations.intermediate.forEach(software => {
                    createSoftwareItem(software, 'intermediate', explanations, listEl);
                });
            }
            
            // Display advanced recommendations
            if (recommendations.advanced && recommendations.advanced.length > 0) {
                const advancedHeader = document.createElement('div');
                advancedHeader.className = 'difficulty-header difficulty-advanced';
                advancedHeader.textContent = 'Advanced';
                listEl.appendChild(advancedHeader);
                
                recommendations.advanced.forEach(software => {
                    createSoftwareItem(software, 'advanced', explanations, listEl);
                });
            }
        }
        
        function createSoftwareItem(software, difficulty, explanations, container) {
            const item = document.createElement('div');
            item.className = `software-item-detailed difficulty-${difficulty}`;
            
            const title = document.createElement('h3');
            title.className = 'software-title';
            title.textContent = software;
            
            const explanation = explanations[software];
            if (explanation) {
                const description = document.createElement('p');
                description.className = 'software-description';
                description.innerHTML = explanation.description;
                
                const why = document.createElement('div');
                why.className = 'software-why';
                why.innerHTML = `<strong>Why this recommendation:</strong> ${explanation.why}`;
                
                // Add download, tutorial, documentation links if available
                if (explanation.download || explanation.tutorial || explanation.documentation) {
                    const links = document.createElement('div');
                    links.className = 'software-links';
                    let linksHTML = '<div class="software-links-grid">';
                    
                    if (explanation.download) {
                        linksHTML += `<div><strong>Download:</strong> ${explanation.download}</div>`;
                    }
                    if (explanation.tutorial) {
                        linksHTML += `<div><strong>Tutorial:</strong> ${explanation.tutorial}</div>`;
                    }
                    if (explanation.documentation) {
                        linksHTML += `<div><strong>Documentation:</strong> ${explanation.documentation}</div>`;
                    }
                    
                    linksHTML += '</div>';
                    links.innerHTML = linksHTML;
                    why.appendChild(links);
                }
                
                item.appendChild(title);
                item.appendChild(description);
                item.appendChild(why);
            } else {
                item.appendChild(title);
            }
            
            container.appendChild(item);
        }

        function visualizeTree(containerId, treeData, selectedPath) {
            const container = document.getElementById(containerId);
            const rootKey = Object.keys(treeData)[0];
            const root = treeData[rootKey];
            
            renderNode(container, root, selectedPath, 0);
        }

        function renderNode(container, node, path, depth) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'tree-node';
            nodeDiv.style.marginLeft = `${depth * 20}px`;
            
            if (node.question) {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'tree-question';
                
                // Check if this question is in the selected path
                const isSelected = path.some(p => p.question === node.question);
                if (isSelected) {
                    questionDiv.classList.add('selected');
                }
                
                questionDiv.textContent = node.question;
                nodeDiv.appendChild(questionDiv);
                container.appendChild(nodeDiv);
                
                // Get all branch keys (excluding 'question')
                const branchKeys = Object.keys(node).filter(key => key !== 'question');
                
                // Render each branch
                branchKeys.forEach(branchKey => {
                    const branchLabel = document.createElement('div');
                    branchLabel.className = 'tree-branch-label';
                    branchLabel.textContent = `↳ ${branchKey.charAt(0).toUpperCase() + branchKey.slice(1)}`;
                    branchLabel.style.marginLeft = `${(depth + 1) * 20}px`;
                    
                    // Check if this branch was selected
                    const branchSelected = path.some(p => p.question === node.question && p.answer === branchKey);
                    if (branchSelected) {
                        branchLabel.classList.add('selected');
                    }
                    
                    container.appendChild(branchLabel);
                    renderNode(container, node[branchKey], path, depth + 1);
                });
            } else if (node.outcome) {
                const outcomeDiv = document.createElement('div');
                outcomeDiv.className = 'tree-outcome';
                
                // Check if this outcome is the final result
                const isSelected = path.some(p => p.outcome === node.outcome.id);
                if (isSelected) {
                    outcomeDiv.classList.add('selected');
                }
                
                outcomeDiv.innerHTML = `<strong>${node.outcome.id}</strong>: ${node.outcome.action}`;
                nodeDiv.appendChild(outcomeDiv);
                container.appendChild(nodeDiv);
            }
        }
    </script>
</body>
</html>
